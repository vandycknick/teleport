---
title: Teleport Kubernetes Access Controls
description: How the Teleport Kubernetes Service applies RBAC to manage access to Kubernetes
---

This guide explains the way the Teleport Kubernetes Service applies role-based
access controls when a Teleport user interacts with a Kubernetes cluster. The
Kubernetes Service intercepts requests to a Kubernetes API server and modifies
each request depending on the user's Teleport roles. 

In this guide, we will show you how to configure the fields available in a
Teleport role to manage access to Kubernetes clusters you have connected to
Teleport.

For an example of how to use Teleport roles to manage access to Kubernetes with
a local `minikube` cluster, see our [RBAC how-to
guide](./manage-access/rbac.mdx).

## Role fields for managing Kubernetes access

### `kubernetes_labels`

You can add labels to a Kubernetes cluster when you register it with Teleport.
You can restrict a user's access to Kubernetes clusters with different labels
using a role's  `kubernetes_labels` field.

```yaml
kind: role
metadata:
  name: kube-access
version: v6
spec:
  allow:
    kubernetes_labels:
      'region': '*'
      'environment': 'development'
# ...
  deny: {}
```

The value of the `kubernetes_labels` field is a mapping from label *keys* to
label *values*. 

If both the key and the value of a label is the wildcard, `*`, the Teleport
Kubernetes Service allows the user to access Kubernetes clusters with all
labels:

```yaml
    kubernetes_labels:
      '*': '*'
```

Otherwise, the Kubernetes Service checks whether one of the keys in
`kubernetes_labels` matches one of the keys corresponding to a registered
Kubernetes cluster. If it does not, there is no matching Kubernetes cluster.

The Kubernetes Service then checks the values of labels with the keys in
`kubernetes_labels`. In `kubernetes_labels`, each value *must* match the value
of a Kubernetes cluster's label before the Kubernetes Service lets a user access
the cluster.

In other words, all labels in `kubernetes_labels` must match a cluster before a
user can access the cluster.

For example, the `kube-access` role above allows a user to access Kubernetes
clusters with the `region` key and any value. It restricts the user to
Kubernetes clusters with the `environment` key and the `development` value.

#### Label values

For the key of a label in `kubernetes_labels` to match the key of a Kubernetes
cluster, the match must be exact.

For values, however, you can use regular expressions or wildcard characters to
match subsets or variations of a string. If a value begins with `^` and ends in
`$`, the Kubernetes Service will treat it as a regular expression using Go's
`re2` syntax (see the `re2`
[README](https://github.com/google/re2/wiki/Syntax)).

Otherwise, the Kubernetes Service evaluates wildcards within the value, matching
them to any sequence of characters in a label. 

Here is an example:

```yaml
spec:
  allow:
    kubernetes_labels:
      'region': 'us-east-*'
      'environment': '^(development|production)$'
```

This `allow` rule matches clusters with the labels `region:us-east-1` and
`region:us-east-2b`, as well as clusters with the labels
`environment:development` and `environment:production`.

#### Applying labels

You can apply labels to an instance of the Teleport Kubernetes Service. The way
to do this depends on how you have launched the service:

<Tabs>
  <TabItem label="Helm">
  Set labels when installing or upgrading the `teleport-kube-agent` Helm chart,
  e.g.:

    ```code
    $ helm upgrade teleport-agent teleport-kube-agent --set kubeClusterName={CLUSTER?}\
      --set proxyAddr=${PROXY?} --set authToken=${TOKEN?} --create-namespace --namespace=teleport-agent\
      --set labels.env=prod --set labels.region=us-west-1
    ```
  </TabItem>

  <TabItem label="Config">
  Setl labels when enabling the Teleport Kubernetes Service in a `teleport`
  instance's configuration file:

    ```yaml
    kubernetes_service:
      enabled: true
      kube_cluster_name: cookie
      labels:
        env: prod
        region: us-west-1
    ```
  </TabItem>
</Tabs>

### `kubernetes_groups` and `kubernetes_users`

The Teleport Kubernetes Service receives requests from end users, e.g., via
`kubectl`, and forwards them to a Kubernetes API server. The Kubernetes Service
uses  [impersonation
headers](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation)
to send requests to the API server with one Kubernetes user and zero or more
Kubernetes groups.

![Impersonation](../../img/k8s/auth.svg)

The `kubernetes_users` and `kubernetes_groups` fields indicate which users and
groups to allow a user to assume when they send requests to a Kubernetes API
server:

```yaml
kind: role
metadata:
  name: kube-access
version: v6
spec:
  allow:
    kubernetes_groups:
    - developers
    - viewers
    kubernetes_users:
    - myuser
    # ...
  deny: {}
```

The value of `kubernetes_groups` and `kubernetes_users` is a list of names of
groups and users to enable impersonation for.

#### How Teleport users impersonate Kubernetes users and groups

There are two ways for an end user to specify which user and groups to
impersonate:

##### Manually

When a user runs `tsh kube login` to authenticate to a Kubernetes cluster, they
can use the `--as` and `--as-groups` flags to manually specify the user and
groups to authenticate as. The Teleport Kubernetes Service determines whether
the user and groups belong to a user's `kubernetes_users` and
`kubernetes_groups` configuration and, if not, denies the user access.

##### Automatically

If the user has not explicitly determined a Kubernetes user and Kubernetes
groups when authenticating to a cluster, the Teleport Kubernetes Service
determines this from the `kubernetes_users` and `kubernetes_groups` fields in a
user's roles.

If a user has exactly one value in `kubernetes_users`, the Teleport Kubernetes
Service impersonates that user. Otherwise, the Kubernetes Service denies the
user access. In this case, the Teleport user must manually specify a Kubernetes
user to impersonate.

If the user has not specified a Kubernetes group to impersonate, the Kubernetes
Service uses all values within `kubernetes_groups`.

With the `kube-access` role above, after you authenticate to Teleport, the
Kubernetes Service uses impersonation headers to forward requests to the API
server with the `developers` group and the `myuser` Kubernetes user.

#### Enabling impersonation

To enable the Kubernetes Service to forward user requests with impersonation
headers, you must ensure that its service account has permissions to impersonate
Kubernetes RBAC principals within your cluster. 

Below is a Kubernetes `ClusterRole` that grants the minimum set of permissions
to enable impersonation, and a `ClusterRoleBinding` that grants these
permissions to a service account.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: teleport-impersonation
rules:
- apiGroups:
  - ""
  resources:
  - users
  - groups
  - serviceaccounts
  verbs:
  - impersonate
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - "authorization.k8s.io"
  resources:
  - selfsubjectaccessreviews
  verbs:
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: teleport
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: teleport-impersonation
subjects:
- kind: ServiceAccount
  name: teleport-serviceaccount
  namespace: default
```

<Notice type="tip">

The [manual methods](./register-clusters.mdx) and [automatic
methods](./discovery.mdx) for registering Kubernetes clusters with Teleport
include steps for setting up the Kubernetes RBAC resources that Teleport needs
to allow access to clusters.

There is usually no need to define these resources manually.

</Notice>

#### Specifying groups and users based on SAML and OIDC traits

Teleport's roles map OIDC claims or SAML attributes using template variables.
The template variable `{{external.groups}}` will be substituted to with a user's
group list in a role definition:

```yaml
kind: role
version: v6
metadata:
  name: group-member
spec:
  allow:
    # For Alice, will be substituted with the list ["admins", "devs"]
    kubernetes_groups: ["{{external.groups}}"]
    # For Alice, will be substituted with ["alice@example.com"]
    kubernetes_users: ["{{external.email}}"]
```

### `kubernetes_resources`

The `kubernetes_resources` field enables a Teleport role to configure access to
specific resources in a Kubernetes cluster:

```yaml
kind: role
metadata:
  name: kube-access
version: v6
spec:
  allow:
    kubernetes_resources:
      - kind: pod
        namespace: "production"
        name: "webapp"
    # ...
```

The value of this field is a list of mappings, where each mapping has three
fields:

- `kind`: The kind of resource to enable access to. Currently, Teleport only
  supports the value `pod`.
- `namespace`: The Kubernetes namespace in which to allow access to a resource.
  In the `kube-access` role, we are allowing access to a pod in the
  `production` namespace.
- `name`: The name of the pod to allow access to. In `kube-access`, this is
  the `webapp` pod. You can add a wildcard character (`*`) to replace any
  sequences of characters. For example, `name: "pod-*-*"` matches pods named
  `pod-1-a` and `pod-2-c`.

## How the Kubernetes Service evaluates Teleport roles

When a Teleport user makes a request to a Kubernetes cluster's API server, the
Teleport Kubernetes Service intercepts the request and inspects the user's
authorization. The Kubernetes Service denies the request if the user is not
authorized to view a particular resource. If the user *is* authorized to perform
their request, the Kubernetes Service modifies the request and forwards it to
the appropriate API server.

### Authorizing user requests

When the Teleport Kubernetes Service receives a request, it evaluates two fields
within the user's roles. If these fields do not allow the user to perform the
request, the Kubernetes Service returns an error to the user:

#### `kubernetes_labels`

The Teleport Kubernetes Service will only allow a user access to a pod if the
cluster where the pod is running has a label that matches a user's
`kubernetes_labels` configuration.

#### `kubernetes_resources`

Some resource URIs within the Kubernetes API server include the names of
specific resources.

For example, if a user runs `kubectl exec` to execute a command against the
`webapp` pod in the `development` namespace, `kubectl` sends a request to the
target cluster's API server at the following path:

```
"/api/v1/namespaces/development/pods/webapp/exec"
```

If a Kubernetes pod is available within the URL path of the request to a
Kubernetes API server, the Teleport Kubernetes Service will check whether the
user is authorized to access that pod.

In the example above, the Kubernetes Service checks if the user is authorized to
access the `webapp` pod in the `development` namespace and, if not, denies the
request.

### Forwarding user requests

Once the Teleport Kubernetes Service has authorized the user to perform a
request against a Kubernetes cluster and (if applicable) a particular resource,
it assembles a request to the upstream API server. It adds impersonation headers
to the request based on the `kubernetes_groups` and `kubernetes_users` fields in
the user's role (see the [discussion of these
fields](#kubernetes_groups_and_kubernetes_users) earlier).

Because the Teleport Kubernetes Service accesses the upstream API server via the
RBAC principals listed in the Teleport user's `kubernetes_groups` and
`kubernetes_users` fields, the principals you specify in these fields must have
access to the resources listed in the user's `kubernetes_resources` field.
Otherwise, the Kubernetes Service will forward a request to the upstream API
server with improper authorization, and the API server will deny the request.

### Multiple roles

#### How the Kubernetes Service evaluates multiple roles

Before evaluating a user's request to a Kubernetes API server, the Teleport
Kubernetes Service checks each of the user's roles. If one role's
`spec.allow.kubernetes_labels` or `spec.allow.kubernetes_resources` conditions
do not match the user's request, the Kubernetes Service checks the next role,
and so on. 

If the Kubernetes Service finds a role with a `spec.allow` condition that
matches all of the cluster's labels and the request's resources, it looks up the
role's `allow.kubernetes_groups` and `allow.kubernetes_users` fields. It adds
these values to a list of RBAC principals it will use to write impersonation
headers later on.

Next, the Kubernetes Service checks each of the user's roles for `spec.deny`
conditions. If one role's `spec.deny.kubernetes_labels` or
`spec.deny.kubernetes_resources` fields match the user's request, the Kubernetes
Service looks up the role's `spec.deny.kubernetes_groups` and
`spec.deny.kubernetes_users` fields. It removes each of these values from the
list of users and groups it created earlier, denying the user access to these
RBAC principals.

#### Example

Let's say you have assigned the following three roles to a user:

```yaml
kind: role
metadata:
  name: allow-dev-us-east-2
version: v6
spec:
  allow:
    kubernetes_labels:
      - "region": "us-east-2"
    kubernetes_resources:
      - kind: pod
        namespace: "development"
        name: "redis-*"
      - kind: pod
        namespace: "development"
        name: "nginx-*"
    kubernetes_groups:
      - dev-viewers # Allows the user to view pods in the development namespace
---
kind: role
metadata:
  name: allow-exec
  version: v6
spec:
  allow:
    kubernetes_labels:
      - "*": "*"
    kubernetes_resources:
      - kind: pod
        namespace: "*"
        name: "*"
    kubernetes_groups:
      - executors # Allows the user to execute commands against any pod
---
kind: role
metadata:
  name: deny-redis-exec
  version: v6
spec:
  deny:
    kubernetes_resources:
      - kind: pod
        namespace: "*"
        name: "redis-*"
    kubernetes_groups:
      - executors
```

The `dev-viewers` Kubernetes group allows the user to view pods in the
`development` namespace. The `executors` Kubernetes group allows the user to
execute commands against any pod in any namespace.

If a user with these roles runs `kubectl get pods/redis-1` in the `development`
namespace, and the cluster has the label `region:us-east-2`, the Kubernetes
Service will accept the request. Since the `deny-redis-exec` role denies the
`executors` group for `redis-*` pods, the Kubernetes Service will forward the
request while impersonating the `dev-viewers` group but *not* the `executors`
group,

However, if the same user runs `kubectl exec -it nginx /bin/bash` in the
`development` namespace, against the same cluster, the Kubernetes Service will
forward the request with an impersonation header for both the `dev-viewers` and
the `executors` groups, since the `deny-redis-exec` role's `deny` condition does
not match the request.

### Security consideration: pod namespace restrictions

When a Teleport user sends a request to list pods, e.g., with `kubectl get
pods`, the Teleport Kubernetes Service does the following:

- Retrieves available pods from the upstream Kubernetes API server, adding
  impersonation headers to the request based on the user's Teleport roles. These
  include the Kubernetes user and groups the user sends the request as.
- Filters the list of available pods based on the pods that the user is
  authorized to access via `kubernetes_resources`.
- Returns the list of pods to the user.

To avoid leaking pods unintentionally, you should ensure that namespace
restrictions in your Kubernetes RBAC line up with those you have set up in
Teleport.

For example, let's say a user has a Teleport role that grants access to any pod
in any namespace, and maps that user to the `default-pod-viewer` Kubernetes
group. This group can only view pods in the `default` namespace:

```yaml
kind: role
metadata:
  name: kube-access-1
version: v6
spec:
  allow:
    kubernetes_groups:
      - default-pod-viewer
    kubernetes_resources:
      - kind: pod
        namespace: "*"
        name: "*"
    # ...
```

The user has a second Teleport role that maps the user to the `system:masters`
Kubernetes group (which can access any pod in any namespace), and grants access
only to the `webapp` pod in the `default` namespace:

```yaml
metadata:
  name: kube-access-2
version: v6
spec:
  allow:
    kubernetes_groups:
      - system:masters
    kubernetes_resources:
      - kind: pod
        namespace: "default"
        name: "webapp"
    # ...
```

Since the `kube-access-2` role maps the user to `system:masters`, when the
Kubernetes Service forwards a request from this user, it will fetch all pods
from the Kubernetes cluster by adding the `system:masters` group to the
request's impersonation headers. 

However, since the user also has a role (`kube-access-1`) that allows access to
all pods in all namespaces, the Kubernetes Service will not filter the pods it
retrieved via its first request to the API server.

In other words, the Kubernetes Service has no way to know that Teleport had
mapped the user to the `system:masters` group in order to grant access to only
the `webapp` pod in the `default` namespace.

<Notice type="warning">

If you have namespace restrictions in your Teleport RBAC, you should
make sure that the same namespace restrictions exist in the Kubernetes RBAC
resources you map to your Teleport users.

</Notice>
