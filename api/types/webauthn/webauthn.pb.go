// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: teleport/legacy/types/webauthn/webauthn.proto

// Package WebAuthn maps WebAuthn messages to protocol buffers.
//
// The mapping is designed to match both the WebAuthn specification and the
// capabilities of current browser implementations.
//
// REST-based Teleport APIs will make an effort to transmit or embed JSON
// messages matching the github.com/go-webauthn/webauthn reference implementation,
// to allow for easy browser integration. gRPC APIs are not meant for REST use
// and thus make no such promises, although the correspondence should be
// obvious.
//
// Note that, ordinarily, various fields in WebAuthn messages are encoded using
// "RawURLEncoding" (aka, base64 URL encoding without padding). This is not the
// case for _any_ of the fields mapped here, all bytes fields are transmitted
// raw/unencoded.

package webauthn

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SessionData stored by the Relying Party during authentication ceremonies.
// Mirrors https://pkg.go.dev/github.com/go-webauthn/webauthn/webauthn#SessionData.
type SessionData struct {
	// Raw challenge used for the ceremony.
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Raw User ID.
	UserId []byte `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"userId,omitempty"`
	// Raw Credential IDs of the credentials allowed for the ceremony.
	AllowCredentials [][]byte `protobuf:"bytes,3,rep,name=allow_credentials,json=allowCredentials,proto3" json:"allowCredentials,omitempty"`
	// True if resident keys were required by the server / Relying Party.
	ResidentKey bool `protobuf:"varint,4,opt,name=resident_key,json=residentKey,proto3" json:"residentKey,omitempty"`
	// Requested user verification requirement, either "discouraged" or
	// "required".
	// An empty value is treated equivalently to "discouraged".
	UserVerification     string   `protobuf:"bytes,5,opt,name=user_verification,json=userVerification,proto3" json:"userVerification,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{0}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(m, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

func (m *SessionData) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *SessionData) GetUserId() []byte {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *SessionData) GetAllowCredentials() [][]byte {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

func (m *SessionData) GetResidentKey() bool {
	if m != nil {
		return m.ResidentKey
	}
	return false
}

func (m *SessionData) GetUserVerification() string {
	if m != nil {
		return m.UserVerification
	}
	return ""
}

// User represents a WebAuthn user.
// Used mainly to correlated a WebAuthn user handle with a Teleport user.
type User struct {
	// Teleport user ID.
	TeleportUser         string   `protobuf:"bytes,1,opt,name=teleport_user,json=teleportUser,proto3" json:"teleport_user,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{1}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetTeleportUser() string {
	if m != nil {
		return m.TeleportUser
	}
	return ""
}

// Credential assertion used for login ceremonies.
type CredentialAssertion struct {
	PublicKey            *PublicKeyCredentialRequestOptions `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *CredentialAssertion) Reset()         { *m = CredentialAssertion{} }
func (m *CredentialAssertion) String() string { return proto.CompactTextString(m) }
func (*CredentialAssertion) ProtoMessage()    {}
func (*CredentialAssertion) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{2}
}
func (m *CredentialAssertion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialAssertion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialAssertion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialAssertion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialAssertion.Merge(m, src)
}
func (m *CredentialAssertion) XXX_Size() int {
	return m.Size()
}
func (m *CredentialAssertion) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialAssertion.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialAssertion proto.InternalMessageInfo

func (m *CredentialAssertion) GetPublicKey() *PublicKeyCredentialRequestOptions {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Request options necessary for credential assertions, aka login ceremonies.
// See https://www.w3.org/TR/webauthn-2/#dictionary-assertion-options or
// refer to navigator.credentials.get in your browser.
type PublicKeyCredentialRequestOptions struct {
	// Raw challenge used for assertion.
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Timeout in milliseconds.
	TimeoutMs int64 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	// Relying Party ID.
	RpId string `protobuf:"bytes,3,opt,name=rp_id,json=rpId,proto3" json:"rp_id,omitempty"`
	// Allowed credentials for assertion.
	AllowCredentials []*CredentialDescriptor `protobuf:"bytes,4,rep,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
	// Extensions supplied by the Relying Party.
	Extensions *AuthenticationExtensionsClientInputs `protobuf:"bytes,5,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// User verification requirement.
	UserVerification     string   `protobuf:"bytes,6,opt,name=user_verification,json=userVerification,proto3" json:"user_verification,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PublicKeyCredentialRequestOptions) Reset()         { *m = PublicKeyCredentialRequestOptions{} }
func (m *PublicKeyCredentialRequestOptions) String() string { return proto.CompactTextString(m) }
func (*PublicKeyCredentialRequestOptions) ProtoMessage()    {}
func (*PublicKeyCredentialRequestOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{3}
}
func (m *PublicKeyCredentialRequestOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeyCredentialRequestOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeyCredentialRequestOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeyCredentialRequestOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeyCredentialRequestOptions.Merge(m, src)
}
func (m *PublicKeyCredentialRequestOptions) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeyCredentialRequestOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeyCredentialRequestOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeyCredentialRequestOptions proto.InternalMessageInfo

func (m *PublicKeyCredentialRequestOptions) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *PublicKeyCredentialRequestOptions) GetTimeoutMs() int64 {
	if m != nil {
		return m.TimeoutMs
	}
	return 0
}

func (m *PublicKeyCredentialRequestOptions) GetRpId() string {
	if m != nil {
		return m.RpId
	}
	return ""
}

func (m *PublicKeyCredentialRequestOptions) GetAllowCredentials() []*CredentialDescriptor {
	if m != nil {
		return m.AllowCredentials
	}
	return nil
}

func (m *PublicKeyCredentialRequestOptions) GetExtensions() *AuthenticationExtensionsClientInputs {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *PublicKeyCredentialRequestOptions) GetUserVerification() string {
	if m != nil {
		return m.UserVerification
	}
	return ""
}

// Assertion response returned by the authenticator.
// Refer to navigator.credentials.get in your browser.
type CredentialAssertionResponse struct {
	// Type of the credential, usually "public-key".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Raw Credential ID.
	RawId []byte `protobuf:"bytes,2,opt,name=raw_id,json=rawId,proto3" json:"raw_id,omitempty"`
	// Assertion response from the authenticator.
	Response *AuthenticatorAssertionResponse `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
	// Extensions supplied by the authenticator.
	Extensions           *AuthenticationExtensionsClientOutputs `protobuf:"bytes,4,opt,name=extensions,proto3" json:"extensions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *CredentialAssertionResponse) Reset()         { *m = CredentialAssertionResponse{} }
func (m *CredentialAssertionResponse) String() string { return proto.CompactTextString(m) }
func (*CredentialAssertionResponse) ProtoMessage()    {}
func (*CredentialAssertionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{4}
}
func (m *CredentialAssertionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialAssertionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialAssertionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialAssertionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialAssertionResponse.Merge(m, src)
}
func (m *CredentialAssertionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CredentialAssertionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialAssertionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialAssertionResponse proto.InternalMessageInfo

func (m *CredentialAssertionResponse) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CredentialAssertionResponse) GetRawId() []byte {
	if m != nil {
		return m.RawId
	}
	return nil
}

func (m *CredentialAssertionResponse) GetResponse() *AuthenticatorAssertionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *CredentialAssertionResponse) GetExtensions() *AuthenticationExtensionsClientOutputs {
	if m != nil {
		return m.Extensions
	}
	return nil
}

// Authenticator assertion response.
// https://www.w3.org/TR/webauthn-2/#authenticatorassertionresponse
type AuthenticatorAssertionResponse struct {
	// Raw client data JSON, exactly as signed by the authenticator.
	// https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
	ClientDataJson []byte `protobuf:"bytes,1,opt,name=client_data_json,json=clientDataJson,proto3" json:"client_data_json,omitempty"`
	// Raw authenticator data, exactly as signed by the authenticator.
	// https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data.
	AuthenticatorData []byte `protobuf:"bytes,2,opt,name=authenticator_data,json=authenticatorData,proto3" json:"authenticator_data,omitempty"`
	// Raw assertion signature performed authenticatorData|clientDataJSON.
	// https://www.w3.org/TR/webauthn-2/#assertion-signature.
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	// Raw user handle returned by the authenticator, if any.
	UserHandle           []byte   `protobuf:"bytes,4,opt,name=user_handle,json=userHandle,proto3" json:"user_handle,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticatorAssertionResponse) Reset()         { *m = AuthenticatorAssertionResponse{} }
func (m *AuthenticatorAssertionResponse) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorAssertionResponse) ProtoMessage()    {}
func (*AuthenticatorAssertionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{5}
}
func (m *AuthenticatorAssertionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorAssertionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorAssertionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorAssertionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorAssertionResponse.Merge(m, src)
}
func (m *AuthenticatorAssertionResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorAssertionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorAssertionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorAssertionResponse proto.InternalMessageInfo

func (m *AuthenticatorAssertionResponse) GetClientDataJson() []byte {
	if m != nil {
		return m.ClientDataJson
	}
	return nil
}

func (m *AuthenticatorAssertionResponse) GetAuthenticatorData() []byte {
	if m != nil {
		return m.AuthenticatorData
	}
	return nil
}

func (m *AuthenticatorAssertionResponse) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AuthenticatorAssertionResponse) GetUserHandle() []byte {
	if m != nil {
		return m.UserHandle
	}
	return nil
}

// Credential creation used for registration ceremonies.
type CredentialCreation struct {
	PublicKey            *PublicKeyCredentialCreationOptions `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *CredentialCreation) Reset()         { *m = CredentialCreation{} }
func (m *CredentialCreation) String() string { return proto.CompactTextString(m) }
func (*CredentialCreation) ProtoMessage()    {}
func (*CredentialCreation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{6}
}
func (m *CredentialCreation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialCreation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialCreation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialCreation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialCreation.Merge(m, src)
}
func (m *CredentialCreation) XXX_Size() int {
	return m.Size()
}
func (m *CredentialCreation) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialCreation.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialCreation proto.InternalMessageInfo

func (m *CredentialCreation) GetPublicKey() *PublicKeyCredentialCreationOptions {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// Request options necessary for credential creation, aka registration
// ceremonies.
// See
// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialcreationoptions
// or refer to navigator.credentials.create in your browser.
type PublicKeyCredentialCreationOptions struct {
	// Raw challenge used for creation.
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	// Relying party information.
	Rp *RelyingPartyEntity `protobuf:"bytes,2,opt,name=rp,proto3" json:"rp,omitempty"`
	// User information.
	User *UserEntity `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// Desired properties for the credential to be created, from most to least
	// preferred.
	CredentialParameters []*CredentialParameter `protobuf:"bytes,4,rep,name=credential_parameters,json=credentialParameters,proto3" json:"credential_parameters,omitempty"`
	// Timeout in milliseconds.
	TimeoutMs int64 `protobuf:"varint,5,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	// Credentials excluded from the ceremony.
	ExcludeCredentials []*CredentialDescriptor `protobuf:"bytes,6,rep,name=exclude_credentials,json=excludeCredentials,proto3" json:"exclude_credentials,omitempty"`
	// Attestation requested, defaulting to "none".
	// https://www.w3.org/TR/webauthn-2/#enumdef-attestationconveyancepreference.
	Attestation string `protobuf:"bytes,7,opt,name=attestation,proto3" json:"attestation,omitempty"`
	// Extensions supplied by the Relying Party.
	Extensions *AuthenticationExtensionsClientInputs `protobuf:"bytes,8,opt,name=extensions,proto3" json:"extensions,omitempty"`
	// Authenticator selection criteria for the new credential.
	AuthenticatorSelection *AuthenticatorSelection `protobuf:"bytes,9,opt,name=authenticator_selection,json=authenticatorSelection,proto3" json:"authenticator_selection,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *PublicKeyCredentialCreationOptions) Reset()         { *m = PublicKeyCredentialCreationOptions{} }
func (m *PublicKeyCredentialCreationOptions) String() string { return proto.CompactTextString(m) }
func (*PublicKeyCredentialCreationOptions) ProtoMessage()    {}
func (*PublicKeyCredentialCreationOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{7}
}
func (m *PublicKeyCredentialCreationOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicKeyCredentialCreationOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicKeyCredentialCreationOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicKeyCredentialCreationOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicKeyCredentialCreationOptions.Merge(m, src)
}
func (m *PublicKeyCredentialCreationOptions) XXX_Size() int {
	return m.Size()
}
func (m *PublicKeyCredentialCreationOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicKeyCredentialCreationOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PublicKeyCredentialCreationOptions proto.InternalMessageInfo

func (m *PublicKeyCredentialCreationOptions) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetRp() *RelyingPartyEntity {
	if m != nil {
		return m.Rp
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetUser() *UserEntity {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetCredentialParameters() []*CredentialParameter {
	if m != nil {
		return m.CredentialParameters
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetTimeoutMs() int64 {
	if m != nil {
		return m.TimeoutMs
	}
	return 0
}

func (m *PublicKeyCredentialCreationOptions) GetExcludeCredentials() []*CredentialDescriptor {
	if m != nil {
		return m.ExcludeCredentials
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetAttestation() string {
	if m != nil {
		return m.Attestation
	}
	return ""
}

func (m *PublicKeyCredentialCreationOptions) GetExtensions() *AuthenticationExtensionsClientInputs {
	if m != nil {
		return m.Extensions
	}
	return nil
}

func (m *PublicKeyCredentialCreationOptions) GetAuthenticatorSelection() *AuthenticatorSelection {
	if m != nil {
		return m.AuthenticatorSelection
	}
	return nil
}

// Credential creation response returned by the authenticator.
// Refer to navigator.credentials.create in your browser.
type CredentialCreationResponse struct {
	// Type of the credential, usually "public-key".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Raw Credential ID.
	RawId []byte `protobuf:"bytes,2,opt,name=raw_id,json=rawId,proto3" json:"raw_id,omitempty"`
	// Attestation response from the authenticator.
	Response *AuthenticatorAttestationResponse `protobuf:"bytes,3,opt,name=response,proto3" json:"response,omitempty"`
	// Extensions supplied by the authenticator.
	Extensions           *AuthenticationExtensionsClientOutputs `protobuf:"bytes,4,opt,name=extensions,proto3" json:"extensions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *CredentialCreationResponse) Reset()         { *m = CredentialCreationResponse{} }
func (m *CredentialCreationResponse) String() string { return proto.CompactTextString(m) }
func (*CredentialCreationResponse) ProtoMessage()    {}
func (*CredentialCreationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{8}
}
func (m *CredentialCreationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialCreationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialCreationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialCreationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialCreationResponse.Merge(m, src)
}
func (m *CredentialCreationResponse) XXX_Size() int {
	return m.Size()
}
func (m *CredentialCreationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialCreationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialCreationResponse proto.InternalMessageInfo

func (m *CredentialCreationResponse) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CredentialCreationResponse) GetRawId() []byte {
	if m != nil {
		return m.RawId
	}
	return nil
}

func (m *CredentialCreationResponse) GetResponse() *AuthenticatorAttestationResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *CredentialCreationResponse) GetExtensions() *AuthenticationExtensionsClientOutputs {
	if m != nil {
		return m.Extensions
	}
	return nil
}

// Attestation response from the authentication, ie, the response to a
// credential creation request.
// https://www.w3.org/TR/webauthn-2/#authenticatorattestationresponse.
type AuthenticatorAttestationResponse struct {
	// Raw client data JSON, exactly as signed by the authenticator.
	// https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata.
	ClientDataJson []byte `protobuf:"bytes,1,opt,name=client_data_json,json=clientDataJson,proto3" json:"client_data_json,omitempty"`
	// Raw attestation object.
	// https://www.w3.org/TR/webauthn-2/#attestation-object
	AttestationObject    []byte   `protobuf:"bytes,2,opt,name=attestation_object,json=attestationObject,proto3" json:"attestation_object,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticatorAttestationResponse) Reset()         { *m = AuthenticatorAttestationResponse{} }
func (m *AuthenticatorAttestationResponse) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorAttestationResponse) ProtoMessage()    {}
func (*AuthenticatorAttestationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{9}
}
func (m *AuthenticatorAttestationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorAttestationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorAttestationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorAttestationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorAttestationResponse.Merge(m, src)
}
func (m *AuthenticatorAttestationResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorAttestationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorAttestationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorAttestationResponse proto.InternalMessageInfo

func (m *AuthenticatorAttestationResponse) GetClientDataJson() []byte {
	if m != nil {
		return m.ClientDataJson
	}
	return nil
}

func (m *AuthenticatorAttestationResponse) GetAttestationObject() []byte {
	if m != nil {
		return m.AttestationObject
	}
	return nil
}

// Extensions supplied by the Relying Party during credential assertion or
// creation.
// https://www.w3.org/TR/webauthn-2/#client-extension-input
type AuthenticationExtensionsClientInputs struct {
	// U2F application ID to be used by the authenticator, if any.
	// Only available if using U2F compatibility mode.
	// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
	AppId                string   `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticationExtensionsClientInputs) Reset()         { *m = AuthenticationExtensionsClientInputs{} }
func (m *AuthenticationExtensionsClientInputs) String() string { return proto.CompactTextString(m) }
func (*AuthenticationExtensionsClientInputs) ProtoMessage()    {}
func (*AuthenticationExtensionsClientInputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{10}
}
func (m *AuthenticationExtensionsClientInputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationExtensionsClientInputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticationExtensionsClientInputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticationExtensionsClientInputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationExtensionsClientInputs.Merge(m, src)
}
func (m *AuthenticationExtensionsClientInputs) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationExtensionsClientInputs) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationExtensionsClientInputs.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationExtensionsClientInputs proto.InternalMessageInfo

func (m *AuthenticationExtensionsClientInputs) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

// Extensions supplied by the authenticator to the Relying Party, during
// credential assertion or creation.
// https://www.w3.org/TR/webauthn-2/#client-extension-output.
type AuthenticationExtensionsClientOutputs struct {
	// If true, the AppID extension was used by the authenticator, which changes
	// the rpIdHash accordingly.
	// https://www.w3.org/TR/webauthn-2/#sctn-appid-extension.
	AppId                bool     `protobuf:"varint,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticationExtensionsClientOutputs) Reset()         { *m = AuthenticationExtensionsClientOutputs{} }
func (m *AuthenticationExtensionsClientOutputs) String() string { return proto.CompactTextString(m) }
func (*AuthenticationExtensionsClientOutputs) ProtoMessage()    {}
func (*AuthenticationExtensionsClientOutputs) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{11}
}
func (m *AuthenticationExtensionsClientOutputs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationExtensionsClientOutputs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticationExtensionsClientOutputs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticationExtensionsClientOutputs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationExtensionsClientOutputs.Merge(m, src)
}
func (m *AuthenticationExtensionsClientOutputs) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationExtensionsClientOutputs) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationExtensionsClientOutputs.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationExtensionsClientOutputs proto.InternalMessageInfo

func (m *AuthenticationExtensionsClientOutputs) GetAppId() bool {
	if m != nil {
		return m.AppId
	}
	return false
}

// Authenticator selection criteria.
// Restricts the choice of authenticator for credential creation.
type AuthenticatorSelection struct {
	// Authenticator attachment, empty means no particular attachment is
	// required.
	AuthenticatorAttachment string `protobuf:"bytes,1,opt,name=authenticator_attachment,json=authenticatorAttachment,proto3" json:"authenticator_attachment,omitempty"`
	// Resident key requirement, if true the authenticator must create a resident
	// key.
	RequireResidentKey bool `protobuf:"varint,2,opt,name=require_resident_key,json=requireResidentKey,proto3" json:"require_resident_key,omitempty"`
	// User verification requirement for authenticators.
	UserVerification     string   `protobuf:"bytes,3,opt,name=user_verification,json=userVerification,proto3" json:"user_verification,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthenticatorSelection) Reset()         { *m = AuthenticatorSelection{} }
func (m *AuthenticatorSelection) String() string { return proto.CompactTextString(m) }
func (*AuthenticatorSelection) ProtoMessage()    {}
func (*AuthenticatorSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{12}
}
func (m *AuthenticatorSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticatorSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticatorSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticatorSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticatorSelection.Merge(m, src)
}
func (m *AuthenticatorSelection) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticatorSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticatorSelection.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticatorSelection proto.InternalMessageInfo

func (m *AuthenticatorSelection) GetAuthenticatorAttachment() string {
	if m != nil {
		return m.AuthenticatorAttachment
	}
	return ""
}

func (m *AuthenticatorSelection) GetRequireResidentKey() bool {
	if m != nil {
		return m.RequireResidentKey
	}
	return false
}

func (m *AuthenticatorSelection) GetUserVerification() string {
	if m != nil {
		return m.UserVerification
	}
	return ""
}

// Public key credential descriptor.
// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialdescriptor.
type CredentialDescriptor struct {
	// Type of the credential, usually "public-key".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Raw Credential ID.
	Id                   []byte   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CredentialDescriptor) Reset()         { *m = CredentialDescriptor{} }
func (m *CredentialDescriptor) String() string { return proto.CompactTextString(m) }
func (*CredentialDescriptor) ProtoMessage()    {}
func (*CredentialDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{13}
}
func (m *CredentialDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialDescriptor.Merge(m, src)
}
func (m *CredentialDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *CredentialDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialDescriptor proto.InternalMessageInfo

func (m *CredentialDescriptor) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CredentialDescriptor) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// Parameters for credential creation.
// https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialparameters.
type CredentialParameter struct {
	// Credential type, usually "public-key".
	// https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// COSE algorithm specifier.
	// Most authenticators support exclusively ES256(-7).
	// https://www.w3.org/TR/webauthn-2/#typedefdef-cosealgorithmidentifier.
	Alg                  int32    `protobuf:"varint,2,opt,name=alg,proto3" json:"alg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CredentialParameter) Reset()         { *m = CredentialParameter{} }
func (m *CredentialParameter) String() string { return proto.CompactTextString(m) }
func (*CredentialParameter) ProtoMessage()    {}
func (*CredentialParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{14}
}
func (m *CredentialParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialParameter.Merge(m, src)
}
func (m *CredentialParameter) XXX_Size() int {
	return m.Size()
}
func (m *CredentialParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialParameter.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialParameter proto.InternalMessageInfo

func (m *CredentialParameter) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CredentialParameter) GetAlg() int32 {
	if m != nil {
		return m.Alg
	}
	return 0
}

// Relying Party information.
// See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialrpentity and
// https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/rp.
type RelyingPartyEntity struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// URL to the icon of the Relying Party.
	Icon                 string   `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelyingPartyEntity) Reset()         { *m = RelyingPartyEntity{} }
func (m *RelyingPartyEntity) String() string { return proto.CompactTextString(m) }
func (*RelyingPartyEntity) ProtoMessage()    {}
func (*RelyingPartyEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{15}
}
func (m *RelyingPartyEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelyingPartyEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelyingPartyEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelyingPartyEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelyingPartyEntity.Merge(m, src)
}
func (m *RelyingPartyEntity) XXX_Size() int {
	return m.Size()
}
func (m *RelyingPartyEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_RelyingPartyEntity.DiscardUnknown(m)
}

var xxx_messageInfo_RelyingPartyEntity proto.InternalMessageInfo

func (m *RelyingPartyEntity) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RelyingPartyEntity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RelyingPartyEntity) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

// User information.
// See https://www.w3.org/TR/webauthn-2/#dictdef-publickeycredentialuserentity
// and
// https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions/user.
type UserEntity struct {
	// Raw ID of the user.
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-palatable name for a user account.
	// The Relying Party _may_ let the user choose this value.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Human-palatable name for the user account, intended only for display.
	// The Relying Party _should_ let the user choose this value.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// URL to a resource which can be the avatar image for the user.
	Icon                 string   `protobuf:"bytes,4,opt,name=icon,proto3" json:"icon,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserEntity) Reset()         { *m = UserEntity{} }
func (m *UserEntity) String() string { return proto.CompactTextString(m) }
func (*UserEntity) ProtoMessage()    {}
func (*UserEntity) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d490a6db28e8798, []int{16}
}
func (m *UserEntity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEntity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEntity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEntity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEntity.Merge(m, src)
}
func (m *UserEntity) XXX_Size() int {
	return m.Size()
}
func (m *UserEntity) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEntity.DiscardUnknown(m)
}

var xxx_messageInfo_UserEntity proto.InternalMessageInfo

func (m *UserEntity) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *UserEntity) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UserEntity) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *UserEntity) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func init() {
	proto.RegisterType((*SessionData)(nil), "webauthn.SessionData")
	proto.RegisterType((*User)(nil), "webauthn.User")
	proto.RegisterType((*CredentialAssertion)(nil), "webauthn.CredentialAssertion")
	proto.RegisterType((*PublicKeyCredentialRequestOptions)(nil), "webauthn.PublicKeyCredentialRequestOptions")
	proto.RegisterType((*CredentialAssertionResponse)(nil), "webauthn.CredentialAssertionResponse")
	proto.RegisterType((*AuthenticatorAssertionResponse)(nil), "webauthn.AuthenticatorAssertionResponse")
	proto.RegisterType((*CredentialCreation)(nil), "webauthn.CredentialCreation")
	proto.RegisterType((*PublicKeyCredentialCreationOptions)(nil), "webauthn.PublicKeyCredentialCreationOptions")
	proto.RegisterType((*CredentialCreationResponse)(nil), "webauthn.CredentialCreationResponse")
	proto.RegisterType((*AuthenticatorAttestationResponse)(nil), "webauthn.AuthenticatorAttestationResponse")
	proto.RegisterType((*AuthenticationExtensionsClientInputs)(nil), "webauthn.AuthenticationExtensionsClientInputs")
	proto.RegisterType((*AuthenticationExtensionsClientOutputs)(nil), "webauthn.AuthenticationExtensionsClientOutputs")
	proto.RegisterType((*AuthenticatorSelection)(nil), "webauthn.AuthenticatorSelection")
	proto.RegisterType((*CredentialDescriptor)(nil), "webauthn.CredentialDescriptor")
	proto.RegisterType((*CredentialParameter)(nil), "webauthn.CredentialParameter")
	proto.RegisterType((*RelyingPartyEntity)(nil), "webauthn.RelyingPartyEntity")
	proto.RegisterType((*UserEntity)(nil), "webauthn.UserEntity")
}

func init() {
	proto.RegisterFile("teleport/legacy/types/webauthn/webauthn.proto", fileDescriptor_0d490a6db28e8798)
}

var fileDescriptor_0d490a6db28e8798 = []byte{
	// 1062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4b, 0x6f, 0x1c, 0x45,
	0x10, 0xd6, 0xec, 0xc3, 0xf1, 0xd6, 0x2e, 0x91, 0xd3, 0x5e, 0x27, 0x8b, 0x71, 0xd6, 0x9b, 0x01,
	0xa4, 0x15, 0x7e, 0x2c, 0x32, 0x70, 0xe0, 0x29, 0xf9, 0x11, 0x84, 0x63, 0x88, 0xad, 0x89, 0x40,
	0x82, 0xcb, 0xa8, 0x3d, 0x53, 0xec, 0x76, 0x98, 0x9d, 0x99, 0x74, 0xf7, 0xc4, 0x59, 0xf1, 0x93,
	0xb8, 0x71, 0xe2, 0xc6, 0x15, 0x89, 0x0b, 0xbf, 0xc0, 0x44, 0x3e, 0xfa, 0x57, 0xa0, 0xee, 0x79,
	0xee, 0xee, 0x38, 0x36, 0x20, 0xe5, 0xd6, 0x53, 0x55, 0x5f, 0x75, 0x77, 0x7d, 0xf5, 0xd5, 0x34,
	0x6c, 0x49, 0xf4, 0x30, 0x0c, 0xb8, 0x1c, 0x78, 0x38, 0xa4, 0xce, 0x64, 0x20, 0x27, 0x21, 0x8a,
	0xc1, 0x19, 0x9e, 0xd2, 0x48, 0x8e, 0xfc, 0x6c, 0xb1, 0x1d, 0xf2, 0x40, 0x06, 0x64, 0x31, 0xfd,
	0x5e, 0x6d, 0x0f, 0x83, 0x61, 0xa0, 0x8d, 0x03, 0xb5, 0x8a, 0xfd, 0xe6, 0x9f, 0x15, 0x68, 0x3e,
	0x41, 0x21, 0x58, 0xe0, 0x1f, 0x50, 0x49, 0xc9, 0x47, 0xd0, 0x70, 0x46, 0xd4, 0xf3, 0xd0, 0x1f,
	0x62, 0xc7, 0xe8, 0x19, 0xfd, 0xd6, 0xde, 0xbd, 0xcb, 0xf3, 0xf5, 0xe5, 0xcc, 0xb8, 0x19, 0x8c,
	0x99, 0xc4, 0x71, 0x28, 0x27, 0x56, 0x1e, 0x49, 0xb6, 0xe0, 0x56, 0x24, 0x90, 0xdb, 0xcc, 0xed,
	0x54, 0x34, 0xa8, 0x7d, 0x79, 0xbe, 0xbe, 0xa4, 0x4c, 0x87, 0x6e, 0x01, 0xb1, 0x10, 0x5b, 0xc8,
	0x11, 0xdc, 0xa1, 0x9e, 0x17, 0x9c, 0xd9, 0x0e, 0x47, 0x17, 0x7d, 0xc9, 0xa8, 0x27, 0x3a, 0xd5,
	0x5e, 0xb5, 0xdf, 0xda, 0xeb, 0x5e, 0x9e, 0xaf, 0xaf, 0x6a, 0xe7, 0x7e, 0xee, 0x2b, 0xa4, 0x58,
	0x9a, 0xf5, 0x91, 0xcf, 0xa0, 0xc5, 0x51, 0x30, 0xf5, 0x6d, 0xff, 0x84, 0x93, 0x4e, 0xad, 0x67,
	0xf4, 0x17, 0xf7, 0xde, 0xbc, 0x3c, 0x5f, 0x5f, 0x49, 0xed, 0x47, 0x38, 0x29, 0xa4, 0x68, 0x16,
	0xcc, 0xea, 0x28, 0xfa, 0xe4, 0xcf, 0x91, 0xb3, 0x1f, 0x99, 0x43, 0x25, 0x0b, 0xfc, 0x4e, 0xbd,
	0x67, 0xf4, 0x1b, 0xf1, 0x51, 0x94, 0xf3, 0xbb, 0x82, 0xaf, 0x78, 0x94, 0x59, 0x9f, 0xb9, 0x01,
	0xb5, 0x6f, 0x05, 0x72, 0xf2, 0x36, 0xbc, 0x91, 0xd2, 0x64, 0xab, 0x20, 0x5d, 0xc9, 0x86, 0xd5,
	0x4a, 0x8d, 0x2a, 0xc8, 0xa4, 0xb0, 0x9c, 0x5f, 0x63, 0x57, 0x08, 0xe4, 0x2a, 0x07, 0x79, 0x04,
	0x10, 0x46, 0xa7, 0x1e, 0x73, 0xf4, 0x65, 0x14, 0xb0, 0xb9, 0xb3, 0xb1, 0x9d, 0xd1, 0x7a, 0xa2,
	0x7d, 0x47, 0x38, 0xc9, 0xb1, 0x16, 0x3e, 0x8b, 0x50, 0xc8, 0xe3, 0x50, 0xe1, 0x85, 0xd5, 0x08,
	0xd3, 0x10, 0xf3, 0xf7, 0x0a, 0x3c, 0xb8, 0x16, 0x40, 0xd6, 0xe6, 0x38, 0x2f, 0x52, 0x7b, 0x1f,
	0x40, 0xb2, 0x31, 0x06, 0x91, 0xb4, 0xc7, 0x42, 0xb3, 0x5b, 0xb5, 0x1a, 0x89, 0xe5, 0x1b, 0x41,
	0x96, 0xa1, 0xce, 0x43, 0xc5, 0x7b, 0x55, 0x5f, 0xb1, 0xc6, 0xc3, 0xab, 0xf8, 0xad, 0xf5, 0xaa,
	0xfd, 0xe6, 0x4e, 0x37, 0xbf, 0x4a, 0x7e, 0xa0, 0x03, 0x14, 0x0e, 0x67, 0xa1, 0x0c, 0x78, 0x09,
	0xbf, 0x8f, 0x01, 0xf0, 0x85, 0x44, 0x5f, 0xf5, 0xa8, 0xd0, 0xd4, 0x34, 0x77, 0xb6, 0xf3, 0x2c,
	0xbb, 0x91, 0x1c, 0xa9, 0xd0, 0x98, 0x82, 0x87, 0x59, 0xe4, 0xbe, 0xc7, 0xd0, 0x97, 0x87, 0x7e,
	0x18, 0x49, 0x61, 0x15, 0x32, 0x90, 0x8d, 0x32, 0xc6, 0x17, 0xf4, 0xe9, 0xe7, 0x19, 0xfd, 0xdb,
	0x80, 0xb7, 0x4a, 0x58, 0xb2, 0x50, 0x84, 0x81, 0x2f, 0x90, 0x10, 0xa8, 0x29, 0x01, 0x26, 0x04,
	0xeb, 0x35, 0x59, 0x81, 0x05, 0x4e, 0xcf, 0x32, 0x2d, 0x58, 0x75, 0x4e, 0xcf, 0x0e, 0x5d, 0x72,
	0x00, 0x8b, 0x3c, 0x81, 0xe9, 0x62, 0x35, 0x77, 0xfa, 0xa5, 0xb7, 0x08, 0xf8, 0xdc, 0x36, 0x56,
	0x86, 0x24, 0xc7, 0x53, 0xd5, 0xa8, 0xe9, 0x3c, 0x83, 0x9b, 0x56, 0xe3, 0x38, 0x92, 0xb3, 0xe5,
	0x30, 0x7f, 0x33, 0xa0, 0xfb, 0xea, 0xdd, 0x49, 0x1f, 0x96, 0x1c, 0x8d, 0xb7, 0x5d, 0x2a, 0xa9,
	0xfd, 0x54, 0x04, 0x7e, 0xd2, 0x27, 0xb7, 0x63, 0xbb, 0x1a, 0x1d, 0x8f, 0x44, 0xe0, 0x93, 0x2d,
	0x20, 0xb4, 0x98, 0x4b, 0x03, 0x92, 0x32, 0xdc, 0x99, 0xf2, 0xe8, 0x69, 0xb3, 0x06, 0x0d, 0xc1,
	0x86, 0x3e, 0x95, 0x11, 0x8f, 0x6b, 0xd2, 0xb2, 0x72, 0x03, 0x59, 0x87, 0xa6, 0x26, 0x6a, 0x44,
	0x7d, 0xd7, 0x43, 0x7d, 0xd7, 0x96, 0x05, 0xca, 0xf4, 0x95, 0xb6, 0x98, 0x14, 0x48, 0xce, 0xcd,
	0x3e, 0x47, 0x7d, 0x67, 0x72, 0x54, 0x22, 0xa0, 0xcd, 0x57, 0x0a, 0x28, 0x85, 0x96, 0x28, 0xe8,
	0x97, 0x1a, 0x98, 0xd7, 0x23, 0xae, 0x91, 0xd0, 0x26, 0x54, 0x78, 0xa8, 0xab, 0xd0, 0xdc, 0x59,
	0xcb, 0x4f, 0x62, 0xa1, 0x37, 0x61, 0xfe, 0xf0, 0x84, 0x72, 0x39, 0x79, 0xe8, 0x4b, 0x26, 0x27,
	0x56, 0x85, 0x87, 0xa4, 0x0f, 0x35, 0x3d, 0x33, 0xe2, 0x1e, 0x69, 0xe7, 0xf1, 0x6a, 0x6a, 0x24,
	0x71, 0x3a, 0x82, 0x58, 0xb0, 0x92, 0x0b, 0xcc, 0x0e, 0x29, 0xa7, 0x63, 0x94, 0xc8, 0x53, 0xa9,
	0xdd, 0x2f, 0x93, 0xda, 0x49, 0x1a, 0x65, 0xb5, 0x9d, 0x79, 0xa3, 0x98, 0x91, 0x7b, 0x7d, 0x56,
	0xee, 0xc7, 0xb0, 0x8c, 0x2f, 0x1c, 0x2f, 0x72, 0x71, 0x4a, 0xdb, 0x0b, 0x37, 0xd2, 0x36, 0x49,
	0xa0, 0x45, 0x75, 0xf7, 0xa0, 0x49, 0xa5, 0x44, 0x21, 0x63, 0x1d, 0xde, 0xd2, 0x3a, 0x2a, 0x9a,
	0x66, 0xf4, 0xbf, 0xf8, 0xbf, 0xf5, 0xff, 0x3d, 0xdc, 0x9b, 0xee, 0x51, 0x81, 0x1e, 0x3a, 0x7a,
	0xf7, 0x86, 0x4e, 0xde, 0xbb, 0x42, 0x96, 0x4f, 0xd2, 0x38, 0xeb, 0x2e, 0x2d, 0xb5, 0x9b, 0x2f,
	0x0d, 0x58, 0x9d, 0x6f, 0x92, 0xff, 0x32, 0x2c, 0xbe, 0x9c, 0x1b, 0x16, 0xef, 0x5d, 0x35, 0x2c,
	0xf2, 0x52, 0xbd, 0x8e, 0x71, 0xf1, 0x33, 0xf4, 0xae, 0xdb, 0xfe, 0x5f, 0xce, 0x8b, 0x3c, 0x81,
	0x1d, 0x9c, 0x3e, 0x45, 0x47, 0x66, 0xf3, 0x22, 0xf7, 0x1c, 0x6b, 0x87, 0xf9, 0x39, 0xbc, 0x73,
	0x13, 0xba, 0x55, 0x51, 0x69, 0xa8, 0xff, 0x4a, 0x71, 0xa9, 0xeb, 0x34, 0x0c, 0x0f, 0x5d, 0xf3,
	0x0b, 0x78, 0xf7, 0x46, 0x17, 0x9e, 0xc1, 0x2f, 0xa6, 0xf8, 0x5f, 0x0d, 0xb8, 0x5b, 0xde, 0x11,
	0xe4, 0x63, 0xe8, 0x4c, 0x37, 0x15, 0x95, 0x92, 0x3a, 0xa3, 0x31, 0xfa, 0x32, 0x39, 0xc3, 0x74,
	0xd3, 0xed, 0x66, 0x6e, 0xf2, 0x3e, 0xb4, 0x39, 0x3e, 0x8b, 0x18, 0x47, 0x7b, 0xea, 0x1d, 0x53,
	0xd1, 0x5b, 0x93, 0xc4, 0x67, 0x15, 0xde, 0x2c, 0xa5, 0x7f, 0xb0, 0xea, 0x15, 0x7f, 0xb0, 0x4f,
	0xa0, 0x5d, 0x26, 0xc6, 0xd2, 0x66, 0xbc, 0x0d, 0x95, 0xac, 0x11, 0x2b, 0xcc, 0x35, 0x3f, 0x2d,
	0x3e, 0x51, 0xb2, 0x21, 0x51, 0x0a, 0x5d, 0x82, 0x2a, 0xf5, 0x86, 0x1a, 0x5b, 0xb7, 0xd4, 0xd2,
	0xfc, 0x1a, 0xc8, 0xfc, 0x84, 0x4b, 0xb6, 0x88, 0x91, 0x15, 0xe6, 0xaa, 0x5c, 0x3e, 0x1d, 0xa3,
	0x06, 0x36, 0x2c, 0xbd, 0x56, 0x36, 0xe6, 0x64, 0x57, 0xd2, 0x6b, 0x73, 0x08, 0x90, 0xcf, 0xbf,
	0x42, 0x96, 0xd6, 0x95, 0x59, 0x1e, 0x40, 0xcb, 0x65, 0x22, 0xf4, 0xe8, 0xc4, 0xd6, 0xbe, 0x38,
	0x5b, 0x33, 0xb1, 0x3d, 0x2e, 0x6e, 0x54, 0xcb, 0x37, 0xda, 0xdb, 0xfb, 0xe3, 0xa2, 0x6b, 0xfc,
	0x75, 0xd1, 0x35, 0x5e, 0x5e, 0x74, 0x8d, 0x1f, 0x3e, 0x1c, 0x32, 0x39, 0x8a, 0x4e, 0xb7, 0x9d,
	0x60, 0x3c, 0x18, 0x72, 0xfa, 0x9c, 0xc5, 0xfd, 0x48, 0xbd, 0x41, 0xf6, 0x0e, 0xa7, 0x21, 0x9b,
	0x79, 0x84, 0x9f, 0x2e, 0xe8, 0xc7, 0xf5, 0x07, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x8f, 0xff,
	0x0d, 0xa1, 0xad, 0x0b, 0x00, 0x00,
}

func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserVerification) > 0 {
		i -= len(m.UserVerification)
		copy(dAtA[i:], m.UserVerification)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.UserVerification)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ResidentKey {
		i--
		if m.ResidentKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.AllowCredentials) > 0 {
		for iNdEx := len(m.AllowCredentials) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowCredentials[iNdEx])
			copy(dAtA[i:], m.AllowCredentials[iNdEx])
			i = encodeVarintWebauthn(dAtA, i, uint64(len(m.AllowCredentials[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TeleportUser) > 0 {
		i -= len(m.TeleportUser)
		copy(dAtA[i:], m.TeleportUser)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.TeleportUser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialAssertion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialAssertion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialAssertion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKeyCredentialRequestOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeyCredentialRequestOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeyCredentialRequestOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserVerification) > 0 {
		i -= len(m.UserVerification)
		copy(dAtA[i:], m.UserVerification)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.UserVerification)))
		i--
		dAtA[i] = 0x32
	}
	if m.Extensions != nil {
		{
			size, err := m.Extensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AllowCredentials) > 0 {
		for iNdEx := len(m.AllowCredentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowCredentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWebauthn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RpId) > 0 {
		i -= len(m.RpId)
		copy(dAtA[i:], m.RpId)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.RpId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TimeoutMs != 0 {
		i = encodeVarintWebauthn(dAtA, i, uint64(m.TimeoutMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialAssertionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialAssertionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialAssertionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Extensions != nil {
		{
			size, err := m.Extensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RawId) > 0 {
		i -= len(m.RawId)
		copy(dAtA[i:], m.RawId)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.RawId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticatorAssertionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorAssertionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticatorAssertionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserHandle) > 0 {
		i -= len(m.UserHandle)
		copy(dAtA[i:], m.UserHandle)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.UserHandle)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthenticatorData) > 0 {
		i -= len(m.AuthenticatorData)
		copy(dAtA[i:], m.AuthenticatorData)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.AuthenticatorData)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientDataJson) > 0 {
		i -= len(m.ClientDataJson)
		copy(dAtA[i:], m.ClientDataJson)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.ClientDataJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialCreation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialCreation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialCreation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PublicKey != nil {
		{
			size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicKeyCredentialCreationOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicKeyCredentialCreationOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicKeyCredentialCreationOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthenticatorSelection != nil {
		{
			size, err := m.AuthenticatorSelection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Extensions != nil {
		{
			size, err := m.Extensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Attestation) > 0 {
		i -= len(m.Attestation)
		copy(dAtA[i:], m.Attestation)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Attestation)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExcludeCredentials) > 0 {
		for iNdEx := len(m.ExcludeCredentials) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExcludeCredentials[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWebauthn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TimeoutMs != 0 {
		i = encodeVarintWebauthn(dAtA, i, uint64(m.TimeoutMs))
		i--
		dAtA[i] = 0x28
	}
	if len(m.CredentialParameters) > 0 {
		for iNdEx := len(m.CredentialParameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CredentialParameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWebauthn(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Rp != nil {
		{
			size, err := m.Rp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialCreationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialCreationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialCreationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Extensions != nil {
		{
			size, err := m.Extensions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWebauthn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RawId) > 0 {
		i -= len(m.RawId)
		copy(dAtA[i:], m.RawId)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.RawId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticatorAttestationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorAttestationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticatorAttestationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AttestationObject) > 0 {
		i -= len(m.AttestationObject)
		copy(dAtA[i:], m.AttestationObject)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.AttestationObject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientDataJson) > 0 {
		i -= len(m.ClientDataJson)
		copy(dAtA[i:], m.ClientDataJson)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.ClientDataJson)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationExtensionsClientInputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationExtensionsClientInputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationExtensionsClientInputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticationExtensionsClientOutputs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationExtensionsClientOutputs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticationExtensionsClientOutputs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppId {
		i--
		if m.AppId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthenticatorSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticatorSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthenticatorSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UserVerification) > 0 {
		i -= len(m.UserVerification)
		copy(dAtA[i:], m.UserVerification)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.UserVerification)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RequireResidentKey {
		i--
		if m.RequireResidentKey {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.AuthenticatorAttachment) > 0 {
		i -= len(m.AuthenticatorAttachment)
		copy(dAtA[i:], m.AuthenticatorAttachment)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.AuthenticatorAttachment)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CredentialParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CredentialParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Alg != 0 {
		i = encodeVarintWebauthn(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelyingPartyEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelyingPartyEntity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelyingPartyEntity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserEntity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEntity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEntity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintWebauthn(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintWebauthn(dAtA []byte, offset int, v uint64) int {
	offset -= sovWebauthn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if len(m.AllowCredentials) > 0 {
		for _, b := range m.AllowCredentials {
			l = len(b)
			n += 1 + l + sovWebauthn(uint64(l))
		}
	}
	if m.ResidentKey {
		n += 2
	}
	l = len(m.UserVerification)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TeleportUser)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialAssertion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKeyCredentialRequestOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.TimeoutMs != 0 {
		n += 1 + sovWebauthn(uint64(m.TimeoutMs))
	}
	l = len(m.RpId)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if len(m.AllowCredentials) > 0 {
		for _, e := range m.AllowCredentials {
			l = e.Size()
			n += 1 + l + sovWebauthn(uint64(l))
		}
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.UserVerification)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialAssertionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.RawId)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorAssertionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientDataJson)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.AuthenticatorData)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.UserHandle)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialCreation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = m.PublicKey.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PublicKeyCredentialCreationOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Rp != nil {
		l = m.Rp.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if len(m.CredentialParameters) > 0 {
		for _, e := range m.CredentialParameters {
			l = e.Size()
			n += 1 + l + sovWebauthn(uint64(l))
		}
	}
	if m.TimeoutMs != 0 {
		n += 1 + sovWebauthn(uint64(m.TimeoutMs))
	}
	if len(m.ExcludeCredentials) > 0 {
		for _, e := range m.ExcludeCredentials {
			l = e.Size()
			n += 1 + l + sovWebauthn(uint64(l))
		}
	}
	l = len(m.Attestation)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.AuthenticatorSelection != nil {
		l = m.AuthenticatorSelection.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialCreationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.RawId)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Extensions != nil {
		l = m.Extensions.Size()
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorAttestationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientDataJson)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.AttestationObject)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticationExtensionsClientInputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticationExtensionsClientOutputs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppId {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthenticatorSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AuthenticatorAttachment)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.RequireResidentKey {
		n += 2
	}
	l = len(m.UserVerification)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.Alg != 0 {
		n += 1 + sovWebauthn(uint64(m.Alg))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelyingPartyEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserEntity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovWebauthn(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWebauthn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWebauthn(x uint64) (n int) {
	return sovWebauthn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = append(m.UserId[:0], dAtA[iNdEx:postIndex]...)
			if m.UserId == nil {
				m.UserId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowCredentials = append(m.AllowCredentials, make([]byte, postIndex-iNdEx))
			copy(m.AllowCredentials[len(m.AllowCredentials)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResidentKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResidentKey = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserVerification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeleportUser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeleportUser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialAssertion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialAssertion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialAssertion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKeyCredentialRequestOptions{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeyCredentialRequestOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeyCredentialRequestOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeyCredentialRequestOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMs", wireType)
			}
			m.TimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowCredentials = append(m.AllowCredentials, &CredentialDescriptor{})
			if err := m.AllowCredentials[len(m.AllowCredentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &AuthenticationExtensionsClientInputs{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserVerification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialAssertionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialAssertionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialAssertionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawId = append(m.RawId[:0], dAtA[iNdEx:postIndex]...)
			if m.RawId == nil {
				m.RawId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &AuthenticatorAssertionResponse{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &AuthenticationExtensionsClientOutputs{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorAssertionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorAssertionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorAssertionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientDataJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientDataJson = append(m.ClientDataJson[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientDataJson == nil {
				m.ClientDataJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticatorData = append(m.AuthenticatorData[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthenticatorData == nil {
				m.AuthenticatorData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserHandle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserHandle = append(m.UserHandle[:0], dAtA[iNdEx:postIndex]...)
			if m.UserHandle == nil {
				m.UserHandle = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialCreation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialCreation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialCreation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKey == nil {
				m.PublicKey = &PublicKeyCredentialCreationOptions{}
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicKeyCredentialCreationOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicKeyCredentialCreationOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicKeyCredentialCreationOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rp == nil {
				m.Rp = &RelyingPartyEntity{}
			}
			if err := m.Rp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserEntity{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialParameters = append(m.CredentialParameters, &CredentialParameter{})
			if err := m.CredentialParameters[len(m.CredentialParameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMs", wireType)
			}
			m.TimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeCredentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExcludeCredentials = append(m.ExcludeCredentials, &CredentialDescriptor{})
			if err := m.ExcludeCredentials[len(m.ExcludeCredentials)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &AuthenticationExtensionsClientInputs{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthenticatorSelection == nil {
				m.AuthenticatorSelection = &AuthenticatorSelection{}
			}
			if err := m.AuthenticatorSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialCreationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialCreationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialCreationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawId = append(m.RawId[:0], dAtA[iNdEx:postIndex]...)
			if m.RawId == nil {
				m.RawId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &AuthenticatorAttestationResponse{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = &AuthenticationExtensionsClientOutputs{}
			}
			if err := m.Extensions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorAttestationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorAttestationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorAttestationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientDataJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientDataJson = append(m.ClientDataJson[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientDataJson == nil {
				m.ClientDataJson = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationObject", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationObject = append(m.AttestationObject[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationObject == nil {
				m.AttestationObject = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationExtensionsClientInputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationExtensionsClientInputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationExtensionsClientInputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticationExtensionsClientOutputs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationExtensionsClientOutputs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationExtensionsClientOutputs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AppId = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthenticatorSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticatorSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticatorSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticatorAttachment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthenticatorAttachment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireResidentKey", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireResidentKey = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserVerification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelyingPartyEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelyingPartyEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelyingPartyEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEntity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEntity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEntity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebauthn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWebauthn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebauthn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWebauthn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWebauthn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWebauthn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWebauthn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWebauthn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWebauthn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWebauthn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWebauthn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWebauthn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWebauthn = fmt.Errorf("proto: unexpected end of group")
)
